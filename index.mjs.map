{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/main.js","../lib/assign.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable array-element-newline */\n\n'use strict';\n\n// MODULES //\n\nimport dtypes from '@stdlib/ndarray-dtypes';\nimport gcusum from '@stdlib/blas-ext-base-ndarray-gcusum';\nimport dcusum from '@stdlib/blas-ext-base-ndarray-dcusum';\nimport scusum from '@stdlib/blas-ext-base-ndarray-scusum';\nimport factory from '@stdlib/ndarray-base-unary-strided1d-dispatch-factory';\n\n\n// VARIABLES //\n\nvar idtypes0 = dtypes( 'numeric_and_generic' ); // input ndarray\nvar idtypes1 = dtypes( 'numeric_and_generic' ); // initial values ndarray\nvar odtypes = dtypes( 'numeric_and_generic' );\nvar policies = {\n\t'output': 'accumulation',\n\t'casting': 'none' // NOTE: in this case, we know that, at least for `gcusum`, all scalar accumulation happens in double-precision, so casting an `int8` array to, e.g., `int32` is not necessary. Were we ever to implement specialized kernels beyond floating-point, we may need to revisit depending on the precision of the underlying accumulators.\n};\nvar table = {\n\t'types': [\n\t\t'float64', 'float64', // input, output\n\t\t'float32', 'float32'  // input, output\n\n\t\t// FIXME: add specialized support for `ccusum` and `zcusum` once the corresponding packages are implemented\n\t],\n\t'fcns': [\n\t\tdcusum,\n\t\tscusum\n\t],\n\t'default': gcusum\n};\nvar options = {\n\t'strictTraversalOrder': true\n};\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions.\n*\n* @private\n* @name cusum\n* @type {Function}\n* @param {ndarray} x - input ndarray\n* @param {ndarray} initial - ndarray containing initial values\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @param {*} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} second argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import scalar2ndarray from '@stdlib/ndarray-from-scalar';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Create an ndarray containing an initial value:\n* var initial = scalar2ndarray( 0.0, {\n*     'dtype': 'float64'\n* });\n*\n* // Perform operation:\n* var out = cusum( x, initial );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nvar cusum = factory( table, [ idtypes0, idtypes1 ], odtypes, policies, options ); // eslint-disable-line max-len\n\n\n// EXPORTS //\n\nexport default cusum;\n\n// exports: { \"assign\": \"cusum.assign\" }\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number';\nimport isComplexLike from '@stdlib/assert-is-complex-like';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport broadcastScalar from '@stdlib/ndarray-base-broadcast-scalar';\nimport maybeBroadcastArray from '@stdlib/ndarray-base-maybe-broadcast-array';\nimport nonCoreShape from '@stdlib/ndarray-base-complement-shape';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getShape from '@stdlib/ndarray-shape';\nimport getOrder from '@stdlib/ndarray-order';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions.\n*\n* @param {ndarrayLike} x - input ndarray\n* @param {(ndarrayLike|number|ComplexLike)} [initial] - initial value\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @param {*} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} initial value argument must be either an ndarray-like object or a numeric value\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Perform operation:\n* var out = cusum( x );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nfunction cusum( x ) {\n\tvar nargs;\n\tvar opts;\n\tvar ord;\n\tvar dt;\n\tvar sh;\n\tvar v;\n\n\tnargs = arguments.length;\n\n\t// Resolve input ndarray meta data:\n\tdt = getDType( x );\n\tord = getOrder( x );\n\n\t// Case: cusum( x )\n\tif ( nargs < 2 ) {\n\t\treturn base( x, broadcastScalar( 0.0, dt, [], ord ) );\n\t}\n\tv = arguments[ 1 ];\n\n\t// Case: cusum( x, ??? )\n\tif ( nargs === 2 ) {\n\t\t// Case: cusum( x, initial_ndarray )\n\t\tif ( isndarrayLike( v ) ) {\n\t\t\t// As the operation is performed across all dimensions, `v` is assumed to be a zero-dimensional ndarray...\n\t\t\treturn base( x, v );\n\t\t}\n\t\t// Case: cusum( x, initial_scalar )\n\t\tif ( isNumber( v ) || isComplexLike( v ) ) {\n\t\t\treturn base( x, broadcastScalar( v, dt, [], ord ) );\n\t\t}\n\t\t// Case: cusum( x, opts )\n\t\topts = v;\n\t\tv = 0.0;\n\n\t\t// Intentionally fall through...\n\t}\n\t// Case: cusum( x, initial, opts )\n\telse { // nargs > 2\n\t\topts = arguments[ 2 ];\n\t}\n\t// Case: cusum( x, initial_ndarray, opts )\n\tif ( isndarrayLike( v ) ) {\n\t\t// When not provided `dims`, the operation is performed across all dimensions and `v` is assumed to be a zero-dimensional ndarray; when `dims` is provided, we need to broadcast `v` to match the shape of the non-core dimensions...\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tv = maybeBroadcastArray( v, nonCoreShape( getShape( x ), opts.dims ) ); // eslint-disable-line max-len\n\t\t}\n\t}\n\t// Case: cusum( x, initial_scalar, opts )\n\telse if ( isNumber( v ) || isComplexLike( v ) ) {\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tsh = nonCoreShape( getShape( x ), opts.dims );\n\t\t} else {\n\t\t\tsh = [];\n\t\t}\n\t\tv = broadcastScalar( v, dt, sh, ord );\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t}\n\treturn base( x, v, opts );\n}\n\n\n// EXPORTS //\n\nexport default cusum;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number';\nimport isComplexLike from '@stdlib/assert-is-complex-like';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport broadcastScalar from '@stdlib/ndarray-base-broadcast-scalar';\nimport maybeBroadcastArray from '@stdlib/ndarray-base-maybe-broadcast-array';\nimport nonCoreShape from '@stdlib/ndarray-base-complement-shape';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getShape from '@stdlib/ndarray-shape';\nimport getOrder from '@stdlib/ndarray-order';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport { assign as base } from './base.js';\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions and assigns the results to a provided output ndarray.\n*\n* @param {ndarrayLike} x - input ndarray\n* @param {(ndarrayLike|number|ComplexLike)} [initial] - initial value\n* @param {ndarrayLike} out - output ndarray\n* @param {Options} [options] - function options\n* @param {integer} [options.dims] - list of dimensions over which to perform operation\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} initial value argument must be either an ndarray-like object or a numeric value\n* @throws {TypeError} output argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var strides = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var offset = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, shape, strides, offset, 'row-major' );\n*\n* // Create an output ndarray:\n* var y = new ndarray( 'float64', ybuf, shape, strides, offset, 'row-major' );\n*\n* // Perform operation:\n* var out = assign( x, y );\n* // returns <ndarray>\n*\n* var bool = ( out === y );\n* // returns true\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nfunction assign( x ) {\n\tvar nargs;\n\tvar opts;\n\tvar ord;\n\tvar out;\n\tvar dt;\n\tvar sh;\n\tvar v;\n\n\tnargs = arguments.length;\n\n\t// Resolve input ndarray meta data:\n\tdt = getDType( x );\n\tord = getOrder( x );\n\n\t// Case: assign( x, out )\n\tif ( nargs < 3 ) {\n\t\treturn base( x, broadcastScalar( 0.0, dt, [], ord ), arguments[ 1 ] );\n\t}\n\tv = arguments[ 1 ];\n\tout = arguments[ 2 ];\n\n\t// Case: assign( x, ???, ??? )\n\tif ( nargs === 3 ) {\n\t\t// Case: assign( x, initial, out )\n\t\tif ( isndarrayLike( out ) ) {\n\t\t\t// Case: assign( x, initial_ndarray, out )\n\t\t\tif ( isndarrayLike( v ) ) {\n\t\t\t\t// As the operation is performed across all dimensions, `v` is assumed to be a zero-dimensional ndarray...\n\t\t\t\treturn base( x, v, out );\n\t\t\t}\n\t\t\t// When computing the sum, initial values must be numeric...\n\t\t\tif ( !isNumber( v ) && !isComplexLike( v ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t\t\t}\n\t\t\t// Case: assign( x, initial_scalar, out )\n\t\t\treturn base( x, broadcastScalar( v, dt, [], ord ), out );\n\t\t}\n\t\t// Case: assign( x, out, opts )\n\t\topts = out;\n\t\tout = v;\n\t\tv = 0.0;\n\n\t\t// Intentionally fall through...\n\t}\n\t// Case: assign( x, initial, out, opts )\n\telse { // nargs > 3\n\t\topts = arguments[ 3 ];\n\t}\n\t// Case: assign( x, initial_ndarray, out, opts )\n\tif ( isndarrayLike( v ) ) {\n\t\t// When not provided `dims`, the operation is performed across all dimensions and `v` is assumed to be a zero-dimensional ndarray; when `dims` is provided, we need to broadcast `v` to match the shape of the non-core dimensions...\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tv = maybeBroadcastArray( v, nonCoreShape( getShape( x ), opts.dims ) ); // eslint-disable-line max-len\n\t\t}\n\t}\n\t// Case: assign( x, initial_scalar, out, opts )\n\telse if ( isNumber( v ) || isComplexLike( v ) ) {\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tsh = nonCoreShape( getShape( x ), opts.dims );\n\t\t} else {\n\t\t\tsh = [];\n\t\t}\n\t\tv = broadcastScalar( v, dt, sh, getOrder( x ) );\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t}\n\treturn base( x, v, out, opts );\n}\n\n\n// EXPORTS //\n\nexport default assign;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute the cumulative sum along one or more ndarray dimensions.\n*\n* @module @stdlib/blas-ext-cusum\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray from '@stdlib/ndarray-ctor';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import cusum from '@stdlib/blas-ext-cusum';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Perform operation:\n* var out = cusum( x );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport assign from './assign.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nexport default main;\n\n// exports: { \"assign\": \"main.assign\" }\n"],"names":["cusum","factory","types","fcns","dcusum","scusum","default","gcusum","dtypes","output","casting","strictTraversalOrder","x","nargs","opts","ord","dt","sh","v","arguments","length","getDType","getOrder","base","broadcastScalar","isndarrayLike","isNumber","isComplexLike","hasOwnProp","maybeBroadcastArray","nonCoreShape","getShape","dims","TypeError","format","assign","out","setReadOnly","main"],"mappings":";;2qDAiCA,IA+EAA,EAAAC,EAxEA,CACAC,MAAA,CACA,UAAA,UACA,UAAA,WAIAC,KAAA,CACAC,EACAC,GAEAC,QAAAC,GA6DA,CA/EAC,EAAA,uBACAA,EAAA,wBACAA,EAAA,uBACA,CACAC,OAAA,eACAC,QAAA,QAeA,CACAC,sBAAA,sBC2BA,SAASX,EAAOY,GACf,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EASJ,GAPAL,EAAQM,UAAUC,OAGlBJ,EAAKK,EAAUT,GACfG,EAAMO,EAAUV,GAGXC,EAAQ,EACZ,OAAOU,EAAMX,EAAGY,EAAiB,EAAKR,EAAI,GAAID,IAK/C,GAHAG,EAAIC,UAAW,GAGA,IAAVN,EAAc,CAElB,GAAKY,EAAeP,GAEnB,OAAOK,EAAMX,EAAGM,GAGjB,GAAKQ,EAAUR,IAAOS,EAAeT,GACpC,OAAOK,EAAMX,EAAGY,EAAiBN,EAAGF,EAAI,GAAID,IAG7CD,EAAOI,EACPA,EAAI,CAGJ,MAGAJ,EAAOK,UAAW,GAGnB,GAAKM,EAAeP,GAEdU,EAAYd,EAAM,UACtBI,EAAIW,EAAqBX,EAAGY,EAAcC,EAAUnB,GAAKE,EAAKkB,YAI3D,KAAKN,EAAUR,KAAOS,EAAeT,GAQzC,MAAM,IAAIe,UAAWC,EAAQ,sGAAuGhB,IANnID,EADIW,EAAYd,EAAM,QACjBgB,EAAcC,EAAUnB,GAAKE,EAAKkB,MAElC,GAENd,EAAIM,EAAiBN,EAAGF,EAAIC,EAAIF,EAGhC,CACD,OAAOQ,EAAMX,EAAGM,EAAGJ,EACpB,CCpDA,SAASqB,EAAQvB,GAChB,IAAIC,EACAC,EACAC,EACAqB,EACApB,EACAC,EACAC,EASJ,GAPAL,EAAQM,UAAUC,OAGlBJ,EAAKK,EAAUT,GACfG,EAAMO,EAAUV,GAGXC,EAAQ,EACZ,OAAOU,EAAMX,EAAGY,EAAiB,EAAKR,EAAI,GAAID,GAAOI,UAAW,IAMjE,GAJAD,EAAIC,UAAW,GACfiB,EAAMjB,UAAW,GAGF,IAAVN,EAAc,CAElB,GAAKY,EAAeW,GAAQ,CAE3B,GAAKX,EAAeP,GAEnB,OAAOK,EAAMX,EAAGM,EAAGkB,GAGpB,IAAMV,EAAUR,KAAQS,EAAeT,GACtC,MAAM,IAAIe,UAAWC,EAAQ,sGAAuGhB,IAGrI,OAAOK,EAAMX,EAAGY,EAAiBN,EAAGF,EAAI,GAAID,GAAOqB,EACnD,CAEDtB,EAAOsB,EACPA,EAAMlB,EACNA,EAAI,CAGJ,MAGAJ,EAAOK,UAAW,GAGnB,GAAKM,EAAeP,GAEdU,EAAYd,EAAM,UACtBI,EAAIW,EAAqBX,EAAGY,EAAcC,EAAUnB,GAAKE,EAAKkB,YAI3D,KAAKN,EAAUR,KAAOS,EAAeT,GAQzC,MAAM,IAAIe,UAAWC,EAAQ,sGAAuGhB,IANnID,EADIW,EAAYd,EAAM,QACjBgB,EAAcC,EAAUnB,GAAKE,EAAKkB,MAElC,GAENd,EAAIM,EAAiBN,EAAGF,EAAIC,EAAIK,EAAUV,GAG1C,CACD,OAAOW,EAAMX,EAAGM,EAAGkB,EAAKtB,EACzB,CC9FAuB,EAAAC,EAAA,SAAAH"}