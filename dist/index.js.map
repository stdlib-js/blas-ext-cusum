{
  "version": 3,
  "sources": ["../lib/non_core_shape.js", "../lib/base.js", "../lib/main.js", "../lib/assign.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar normalizeIndices = require( '@stdlib/ndarray-base-to-unique-normalized-indices' );\nvar indicesComplement = require( '@stdlib/array-base-indices-complement' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\n\n\n// MAIN //\n\n/**\n* Returns the shape defined by the dimensions which are **not** included in a list of dimensions.\n*\n* @private\n* @param {NonNegativeIntegerArray} shape - input ndarray\n* @param {IntegerArray} dims - list of dimensions\n* @returns {NonNegativeIntegerArray} shape\n*/\nfunction nonCoreShape( shape, dims ) { // TODO: consider moving to a `@stdlib/ndarray/base` utility\n\tvar ind = normalizeIndices( dims, shape.length-1 );\n\tif ( ind === null ) {\n\t\t// Note: this is an error condition, as `null` is returned when provided out-of-bounds indices...\n\t\treturn [];\n\t}\n\treturn takeIndexed( shape, indicesComplement( shape.length, ind ) );\n}\n\n\n// EXPORTS //\n\nmodule.exports = nonCoreShape;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable array-element-newline */\n\n'use strict';\n\n// MODULES //\n\nvar dtypes = require( '@stdlib/ndarray-dtypes' );\nvar gcusum = require( '@stdlib/blas-ext-base-ndarray-gcusum' );\nvar dcusum = require( '@stdlib/blas-ext-base-ndarray-dcusum' );\nvar scusum = require( '@stdlib/blas-ext-base-ndarray-scusum' );\nvar factory = require( '@stdlib/ndarray-base-unary-strided1d-dispatch-factory' );\n\n\n// VARIABLES //\n\nvar idtypes0 = dtypes( 'numeric_and_generic' ); // input ndarray\nvar idtypes1 = dtypes( 'numeric_and_generic' ); // initial values ndarray\nvar odtypes = dtypes( 'numeric_and_generic' );\nvar policies = {\n\t'output': 'accumulation',\n\t'casting': 'none' // NOTE: in this case, we know that, at least for `gcusum`, all scalar accumulation happens in double-precision, so casting an `int8` array to, e.g., `int32` is not necessary. Were we ever to implement specialized kernels beyond floating-point, we may need to revisit depending on the precision of the underlying accumulators.\n};\nvar table = {\n\t'types': [\n\t\t'float64', 'float64', // input, output\n\t\t'float32', 'float32'  // input, output\n\n\t\t// FIXME: add specialized support for `ccusum` and `zcusum` once the corresponding packages are implemented\n\t],\n\t'fcns': [\n\t\tdcusum,\n\t\tscusum\n\t],\n\t'default': gcusum\n};\nvar options = {\n\t'strictTraversalOrder': true\n};\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions.\n*\n* @private\n* @name cusum\n* @type {Function}\n* @param {ndarray} x - input ndarray\n* @param {ndarray} initial - ndarray containing initial values\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @param {string} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} second argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var scalar2ndarray = require( '@stdlib/ndarray-from-scalar' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Create an ndarray containing an initial value:\n* var initial = scalar2ndarray( 0.0, {\n*     'dtype': 'float64'\n* });\n*\n* // Perform operation:\n* var out = cusum( x, initial );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nvar cusum = factory( table, [ idtypes0, idtypes1 ], odtypes, policies, options ); // eslint-disable-line max-len\n\n\n// EXPORTS //\n\nmodule.exports = cusum;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;\nvar isComplexLike = require( '@stdlib/assert-is-complex-like' );\nvar isndarrayLike = require( '@stdlib/assert-is-ndarray-like' );\nvar broadcastScalar = require( '@stdlib/ndarray-base-broadcast-scalar' );\nvar maybeBroadcastArray = require( '@stdlib/ndarray-base-maybe-broadcast-array' );\nvar getDType = require( '@stdlib/ndarray-dtype' );\nvar getShape = require( '@stdlib/ndarray-shape' );\nvar getOrder = require( '@stdlib/ndarray-order' );\nvar format = require( '@stdlib/string-format' );\nvar nonCoreShape = require( './non_core_shape.js' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions.\n*\n* @param {ndarrayLike} x - input ndarray\n* @param {(ndarrayLike|number|ComplexLike)} [initial] - initial value\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @param {string} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} initial value argument must be either an ndarray-like object or a numeric value\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Perform operation:\n* var out = cusum( x );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nfunction cusum( x ) {\n\tvar nargs;\n\tvar opts;\n\tvar ord;\n\tvar dt;\n\tvar sh;\n\tvar v;\n\n\tnargs = arguments.length;\n\n\t// Resolve input ndarray meta data:\n\tdt = getDType( x );\n\tord = getOrder( x );\n\n\t// Case: cusum( x )\n\tif ( nargs < 2 ) {\n\t\treturn base( x, broadcastScalar( 0.0, dt, [], ord ) );\n\t}\n\tv = arguments[ 1 ];\n\n\t// Case: cusum( x, ??? )\n\tif ( nargs === 2 ) {\n\t\t// Case: cusum( x, initial_ndarray )\n\t\tif ( isndarrayLike( v ) ) {\n\t\t\t// As the operation is performed across all dimensions, `v` is assumed to be a zero-dimensional ndarray...\n\t\t\treturn base( x, v );\n\t\t}\n\t\t// Case: cusum( x, initial_scalar )\n\t\tif ( isNumber( v ) || isComplexLike( v ) ) {\n\t\t\treturn base( x, broadcastScalar( v, dt, [], ord ) );\n\t\t}\n\t\t// Case: cusum( x, opts )\n\t\topts = v;\n\t\tv = 0.0;\n\n\t\t// Intentionally fall through...\n\t}\n\t// Case: cusum( x, initial, opts )\n\telse { // nargs > 2\n\t\topts = arguments[ 2 ];\n\t}\n\t// Case: cusum( x, initial_ndarray, opts )\n\tif ( isndarrayLike( v ) ) {\n\t\t// When not provided `dims`, the operation is performed across all dimensions and `v` is assumed to be a zero-dimensional ndarray; when `dims` is provided, we need to broadcast `v` to match the shape of the non-core dimensions...\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tv = maybeBroadcastArray( v, nonCoreShape( getShape( x ), opts.dims ) ); // eslint-disable-line max-len\n\t\t}\n\t}\n\t// Case: cusum( x, initial_scalar, opts )\n\telse if ( isNumber( v ) || isComplexLike( v ) ) {\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tsh = nonCoreShape( getShape( x ), opts.dims );\n\t\t} else {\n\t\t\tsh = [];\n\t\t}\n\t\tv = broadcastScalar( v, dt, sh, getOrder( x ) );\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t}\n\treturn base( x, v, opts );\n}\n\n\n// EXPORTS //\n\nmodule.exports = cusum;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;\nvar isComplexLike = require( '@stdlib/assert-is-complex-like' );\nvar isndarrayLike = require( '@stdlib/assert-is-ndarray-like' );\nvar broadcastScalar = require( '@stdlib/ndarray-base-broadcast-scalar' );\nvar maybeBroadcastArray = require( '@stdlib/ndarray-base-maybe-broadcast-array' );\nvar getDType = require( '@stdlib/ndarray-dtype' );\nvar getShape = require( '@stdlib/ndarray-shape' );\nvar getOrder = require( '@stdlib/ndarray-order' );\nvar format = require( '@stdlib/string-format' );\nvar nonCoreShape = require( './non_core_shape.js' );\nvar base = require( './base.js' ).assign;\n\n\n// MAIN //\n\n/**\n* Computes the cumulative sum along one or more ndarray dimensions and assigns the results to a provided output ndarray.\n*\n* @param {ndarrayLike} x - input ndarray\n* @param {(ndarrayLike|number|ComplexLike)} [initial] - initial value\n* @param {ndarrayLike} out - output ndarray\n* @param {Options} [options] - function options\n* @param {string} [options.dtype] - output ndarray data type\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} initial value argument must be either an ndarray-like object or a numeric value\n* @throws {TypeError} output argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the shape of the input array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var strides = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var offset = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, shape, strides, offset, 'row-major' );\n*\n* // Create an output ndarray:\n* var y = new ndarray( 'float64', ybuf, shape, strides, offset, 'row-major' );\n*\n* // Perform operation:\n* var out = assign( x, y );\n* // returns <ndarray>\n*\n* var bool = ( out === y );\n* // returns true\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\nfunction assign( x ) {\n\tvar nargs;\n\tvar opts;\n\tvar ord;\n\tvar out;\n\tvar dt;\n\tvar sh;\n\tvar v;\n\n\tnargs = arguments.length;\n\n\t// Resolve input ndarray meta data:\n\tdt = getDType( x );\n\tord = getOrder( x );\n\n\t// Case: assign( x, out )\n\tif ( nargs < 3 ) {\n\t\treturn base( x, broadcastScalar( 0.0, dt, [], ord ), arguments[ 1 ] );\n\t}\n\tv = arguments[ 1 ];\n\tout = arguments[ 2 ];\n\n\t// Case: assign( x, ???, ??? )\n\tif ( nargs === 3 ) {\n\t\t// Case: assign( x, initial, out )\n\t\tif ( isndarrayLike( out ) ) {\n\t\t\t// Case: assign( x, initial_ndarray, out )\n\t\t\tif ( isndarrayLike( v ) ) {\n\t\t\t\t// As the operation is performed across all dimensions, `v` is assumed to be a zero-dimensional ndarray...\n\t\t\t\treturn base( x, v, out );\n\t\t\t}\n\t\t\t// When computing the sum, initial values must be numeric...\n\t\t\tif ( !isNumber( v ) && !isComplexLike( v ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t\t\t}\n\t\t\t// Case: assign( x, initial_scalar, out )\n\t\t\treturn base( x, broadcastScalar( v, dt, [], ord ), out );\n\t\t}\n\t\t// Case: assign( x, out, opts )\n\t\topts = out;\n\t\tout = v;\n\t\tv = 0.0;\n\n\t\t// Intentionally fall through...\n\t}\n\t// Case: assign( x, initial, out, opts )\n\telse { // nargs > 3\n\t\topts = arguments[ 3 ];\n\t}\n\t// Case: assign( x, initial_ndarray, out, opts )\n\tif ( isndarrayLike( v ) ) {\n\t\t// When not provided `dims`, the operation is performed across all dimensions and `v` is assumed to be a zero-dimensional ndarray; when `dims` is provided, we need to broadcast `v` to match the shape of the non-core dimensions...\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tv = maybeBroadcastArray( v, nonCoreShape( getShape( x ), opts.dims ) ); // eslint-disable-line max-len\n\t\t}\n\t}\n\t// Case: assign( x, initial_scalar, out, opts )\n\telse if ( isNumber( v ) || isComplexLike( v ) ) {\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tsh = nonCoreShape( getShape( x ), opts.dims );\n\t\t} else {\n\t\t\tsh = [];\n\t\t}\n\t\tv = broadcastScalar( v, dt, sh, getOrder( x ) );\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray or a numeric scalar value. Value: `%s`.', v ) );\n\t}\n\treturn base( x, v, out, opts );\n}\n\n\n// EXPORTS //\n\nmodule.exports = assign;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute the cumulative sum along one or more ndarray dimensions.\n*\n* @module @stdlib/blas-ext-cusum\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray = require( '@stdlib/ndarray-ctor' );\n* var ndarray2array = require( '@stdlib/ndarray-to-array' );\n* var cusum = require( '@stdlib/blas-ext-cusum' );\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Perform operation:\n* var out = cusum( x );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ 1.0, 3.0 ] ], [ [ 0.0, 4.0 ] ], [ [ -1.0, 5.0 ] ] ]\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n\n// exports: { \"assign\": \"main.assign\" }\n"],
  "mappings": "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",
  "names": ["require_non_core_shape", "__commonJSMin", "exports", "module", "normalizeIndices", "indicesComplement", "takeIndexed", "nonCoreShape", "shape", "dims", "ind", "require_base", "__commonJSMin", "exports", "module", "dtypes", "gcusum", "dcusum", "scusum", "factory", "idtypes0", "idtypes1", "odtypes", "policies", "table", "options", "cusum", "require_main", "__commonJSMin", "exports", "module", "hasOwnProp", "isNumber", "isComplexLike", "isndarrayLike", "broadcastScalar", "maybeBroadcastArray", "getDType", "getShape", "getOrder", "format", "nonCoreShape", "base", "cusum", "x", "nargs", "opts", "ord", "dt", "sh", "v", "require_assign", "__commonJSMin", "exports", "module", "hasOwnProp", "isNumber", "isComplexLike", "isndarrayLike", "broadcastScalar", "maybeBroadcastArray", "getDType", "getShape", "getOrder", "format", "nonCoreShape", "base", "assign", "x", "nargs", "opts", "ord", "out", "dt", "sh", "v", "setReadOnly", "main", "assign"]
}
